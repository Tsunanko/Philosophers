# Philosophers 問題の進め方ガイド

このガイドは、42/Philosophers 課題の必須部分を中心に、実装を始めるための手順と設計上のヒントをまとめたものです。ボーナスは必須が完成した後に取り組めば十分です。

## 1. 仕様の読み下し
- 引数: `number_of_philosophers time_to_die time_to_eat time_to_sleep [number_of_times_each_philosopher_must_eat]`
- 制約: グローバル変数禁止、pthread と mutex のみ使用可、ログの競合禁止、死亡検出は 10ms 以内。

## 2. データ構造の設計
- `t_sim`: 時刻基準 (start_ts)、設定値、終了フラグ、出力用 mutex。
- `t_fork`: フォーク用 mutex。
- `t_philo`: 番号、左右フォークへのポインタ、最後に食べた時刻、食事回数、監視用 mutex。

## 3. 初期化手順
1. 引数を整数に安全に変換しバリデーション (0 以下禁止、philo 数は 1 以上)。
2. `t_sim` を確保し、開始時刻を `gettimeofday` で記録。
3. フォーク配列を生成し `pthread_mutex_init`。
4. 哲学者配列を生成し、左右フォークを割り当て、監視用 mutex を初期化。

## 4. スレッド設計
- **哲学者スレッド**: ループで `think → take forks → eat → sleep`。フォーク取得は順番を決めてデッドロックを避ける (偶数先に右、奇数先に左など)。
- **監視スレッド**: 各哲学者の生存と食事回数を定期的にチェック。`time_to_die` を超えたら終了フラグを立てて死亡ログを出力。
- スレッドの終了判定は共有フラグを読み取り、読み書き時は mutex で保護。

## 5. 時間管理
- 時刻はミリ秒単位で扱う。`gettimeofday` を基準時刻との差分でラップ。
- `usleep` は小刻みに呼び、終了フラグを頻繁に確認して待機を中断できるようにする。

## 6. ログ出力
- `print_status(sim, philo, "is eating")` のような関数で一元管理し、出力前に共有フラグを確認。
- 出力は必ず単一の mutex でシリアライズすることでメッセージの混在を防ぐ。

## 7. 終了処理
- 監視スレッドが終了フラグをセットしたら、全哲学者スレッドを `pthread_join`。
- すべての mutex を `pthread_mutex_destroy` し、動的メモリを解放。

## 8. テストのヒント
- `1 800 200 200` で孤立哲学者の死亡タイミングを確認。
- `5 800 200 200 7` のように食事回数指定で停止判定を確認。
- `valgrind` でリークと誤用 (Mutex, thread join) をチェック。

## 9. ボーナスの着手目安
- 必須を完全クリア後、プロセス + セマフォ版へ移行。全フォークをカウントセマフォ、出力をバイナリセマフォで管理し、子プロセスの監視を親で統合。

## 10. よくある落とし穴
- ミリ秒変換のオーバーフロー、負の引数処理漏れ。
- `usleep` の長時間呼び出しで死亡検知が遅れるケース。
- 共有フラグを複数箇所で無保護に読み書きしてデータ競合が発生するケース。

この流れに沿って最小限の骨組みを作り、段階的にデバッグを進めるのが最短ルートです。
